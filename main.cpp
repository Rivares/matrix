#include <gperftools/profiler.h>

#include <iostream>

#include <unordered_set>
#include <cassert>
#include <string>
#include <tuple>

#include "lib.hpp"



int main()
{
    ProfilerStart("matrix.prof");

///   Спроектировать 2-мерную разреженную бесконечную матрицу, заполненную значениями по
///   умолчанию. Матрица должна хранить только занятые элементы - значения которых хотя бы раз
///   присваивались. Присвоение в ячейку значения по умолчанию освобождает ячейку.
///   Необходимо уметь отвечать на вопрос - сколько ячеек реально занято?
///   Необходимо уметь проходить по всем занятым ячейкам. Порядок не имеет значения. Возвращается
///   позиция ячейки и ее значение.
///   При чтении элемента из свободной ячейки возвращать значение по умолчанию.


    {
        /*!
            При запуске программы необходимо создать матрицу с пустым значением 0, заполнить главную
            диагональ матрицы (от [0,0] до [9,9]) значениями от 0 до 9.
            Второстепенную диагональ (от [0,9] до [9,0]) значениями от 9 до 0.
            Необходимо вывести фрагмент матрицы от [1,1] до [8,8]. Между столбцами пробел. Каждая строка
            матрицы на новой строке консоли.
            Вывести количество занятых ячеек.
            Вывести все занятые ячейки вместе со своими позициями.
            Опционально реализовать N-мерную матрицу.
            Опционально реализовать каноническую форму оператора `=`, допускающую выражения
            `((matrix[100][100] = 314) = 0) = 217`
        */

        std::cout << "Constructions project of objects:\n\n";


        Matrix<int, 0> matrix;


        std::cout << "\nWork part:\n\n";

        assert(matrix.size() == 0); // все ячейки свободны

        for (size_t i = 0, j = 9; i < 10; ++i, --j)
        {
            matrix[i][i] = i;
            matrix[i][j] = j;
        }

        for (size_t i = 1; i < 10; ++i)
        {
            auto [x, y, v, w] = matrix[i][i];
            std::cout << v << ' ' << '\n'; // TODO
        }

        std::cout << "\nSize of matix = " << matrix.size() << '\n';

        for(auto item: matrix)
        {
            int x;
            int y;
            int v;
            std::tie(x, y, v) = item;
            std::cout << x << y << v << std::endl;
        }

        ((matrix[100][100] = 314) = 0) = 217;
        assert(matrix.size() == (18 + 1));
        assert(matrix[100][100] == 217);

        std::cout << "\n\nDestructions objects:\n";
    }

    std::cout << "\n";


    ProfilerStop();
    return 0;
}


